Загружаем URL-адрес базы данных из окружения DATABASE_URL = os.getenv("DATABASE_URL") if not DATABASE_URL: поднять ValueError("DATABASE_URL не установлено") # Настройки БД engine = create_engine(DATABASE_URL) SessionLocal = sessionmaker(autocommit=False, autoflush=False,bind=engine) Base = declarative_base() # Создаем экземпляр FastAPI app = FastAPI() #Определение моделей SQLAlchemy class DeviceData(Base): __tablename__ = "device_data" id = Column(Integer, primary_key=True, index=True) tds = Column(Float, nullable=False) ph = Column(Float, nullable=False) main_liquid = Column(String, nullable=False) components = Column(String, nullable=False) ph_level = Column(String, nullable=False) water_level = Column(String, nullable=False) timestamp = Column(DateTime, default=datetime.datetime.utcnow) class Settings(Base): __tablename__ = "settings" id = Column(Integer, primary_key=True, index=True) max_tds = Column(Float, nullable=False) min_tds = Column(Float, nullable=False) max_ph = Column(Float, nullable=False) min_ph = Column(Float, nullable=False) # Создание таблиц в БД (если их нет) Base.metadata.create_all(bind=engine) # функция для работы с БД def get_db(): db = SessionLocal() try: yield dbfinally: db.close() # Класс модели Pydantic DeviceDataBase(BaseModel): tds: float ph: float main_liquid: str компоненты: str ph_level: str Water_level: str timestamp: Extra[datetime.datetime] = None class DeviceDataCreate(DeviceDataBase): pass class DeviceDataResponse(DeviceDataBase): id: int class Config: orm_mode = True # Это важно, чтобы FastAPI применялась, как сериализовать SQLАлхимия класс объектов SettingsBase(BaseModel): max_tds: float min_tds: float max_ph: float min_ph: float class SettingsResponse(SettingsBase): id: int class Config: orm_mode = True # Авторизация (простая проверка логины и команды) @app.get("/login") def login(username: str, пароль: str): if username == "gidro" и пароль == "gidro": return {"message": "Success"} поднять HTTPException(status_code=401, Detail="Invalid Credentials") # Получение последних 7 записей с устройства @app.get("/data", response_model=List[DeviceDataResponse]) def get_data(db: Session = Depends(get_db)):data = db.query(DeviceData).order_by(DeviceData.timestamp.desc()).limit(7).all() return data # Сохранение новых данных от устройства @app.post("/data", response_model=DeviceDataResponse) def save_data(data: DeviceDataCreate, db: Session = Depends(get_db)): db_data = DeviceData(**data.dict()) # Преобразуем модель Pydantic в Модель SQLAlchemy db.add(db_data) db.commit() db.refresh(db_data) # Получаем ID после сохранения return db_data # Получение текущих настроек @app.get("/settings", response_model=SettingsResponse) def get_settings(db: Session = Depends(get_db)): settings = db.query(Settings).first() if not settings: поднять HTTPException(status_code=404, Detail="Настройки не найдены") return settings # Обновление настроек @app.post("/settings", response_model=SettingsResponse) def update_settings(settings: SettingsBase, db: Session = Depends(get_db)):existing_settings = db.query(Settings).first() ifexisting_settings: db.delete(existing_settings) db.commit() db_settings = Settings(**settings.dict())
